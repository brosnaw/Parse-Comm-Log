// Parse Comm Log - Parse file generated by the AVP communications analyzer page dump
//

#include "stdafx.h"

#include <fstream>
#include <locale>
#include <new>
#include "ParseCommLog.hpp"
#include "spinner.hpp"
#include <ostream>
#include <stdlib.h> 
#include <string>

//using namespace std;

// Purpose: Finds the messages in the byte stream and pushes them into the messages vector
void searchForMessage(StatusAndData status_and_data)
{
	if (status_and_data.commentByte())
	{
		// This is a comment byte
		if (current_message.direction == Direction::UNKNOWN)
		{
			// Catching the middle of a COMMENT
			current_message.startNew(Direction::COMMENT, NO_START_OF_MESSAGE_DETECTED);
		}
		else if (current_message.direction != Direction::COMMENT)
		{
			// Implied start of message
			messages.push_back(current_message); // Last message is complete save it
			current_message.startNew(Direction::COMMENT, NO_START_OF_MESSAGE_DETECTED);
		}
		// else it's another byte in a comment
	}
	else if (status_and_data.tx())
	{
		// Byte TX'd. If last byte was RX'd this implies start of new message
		if (current_message.direction == Direction::UNKNOWN)
		{
			// Catching the middle of a TX'd message
			current_message.startNew(Direction::TX, NO_START_OF_MESSAGE_DETECTED);
		}
		else if (current_message.direction != Direction::TX)
		{
			// Implied start of message
			messages.push_back(current_message); // Last message is complete save it
			current_message.startNew(Direction::TX, START_OF_MESSAGE_DETECTED);
		}
		// else it's another byte in a TX message
	}
	else if (status_and_data.rx() && status_and_data.addressByte())
	{
		// Message RX'd with clear start of message
		if (current_message.direction != Direction::UNKNOWN)
		{
			messages.push_back(current_message); // Last message is complete save it
		}

		current_message.startNew(Direction::RX, START_OF_MESSAGE_DETECTED);
	}
	else if (status_and_data.rx())
	{
		// Byte RX'd. If last byte was not RX'd this implies start of a new message
		if (current_message.direction == Direction::UNKNOWN)
		{
			// Catching the middle of an RX'd message
			current_message.startNew(Direction::RX, NO_START_OF_MESSAGE_DETECTED);
		}
		else if (current_message.direction != Direction::RX)
		{
			// Implied start of message
			messages.push_back(current_message); // Last message is complete save it
			current_message.startNew(Direction::RX, NO_START_OF_MESSAGE_DETECTED);
		}
		// else it's another byte in an RX message
	}

//#define __ACTUALLY_PARSE_IT__
#ifdef __ACTUALLY_PARSE_IT__
	// Add the translated raw bytes
	std::ostringstream ss;
	ss << ' ' << status_and_data;
	current_message.data += ss.str();
#endif

#define __SAVE_BYTES__
#ifdef __SAVE_BYTES__
	// Add the raw bytes
	current_message.raw_status_and_data_bytes.push_back(status_and_data);
#endif
}

// Purpose: Parse a request (from the system)
void parseRequest(Message &message)
{
	// If SAS
	std::ostringstream ss; // (message.description);

	if (message.raw_status_and_data_bytes[0].addressByte())
	{
		if (message.raw_status_and_data_bytes[0].broadcastPoll())
		{
			ss << "BP[";
			ss << std::hex << std::setfill('0') << std::setw(2) << (int)message.raw_status_and_data_bytes[0].data << "]";

			last_request = BP_REQUEST;
		}
		else if (message.raw_status_and_data_bytes[0].generalPoll())
		{
			ss << "GP[";
			ss << std::hex << std::setfill('0') << std::setw(2) << (int)message.raw_status_and_data_bytes[0].data << "]";

			last_request = GP_REQUEST;
		}
		else if (message.raw_status_and_data_bytes[0].longPoll())
		{
			ss << long_poll[message.raw_status_and_data_bytes[0].data] << ':';
			last_request = LP_REQUEST;
		}
		else
		{
			ss << "??[";
			ss << std::hex << std::setfill('0') << std::setw(2) << (int)message.raw_status_and_data_bytes[0].data << "]";
			last_request = UNKNOWN_REQUEST;
		}
	}
	else
	{
		ss << "Missing start of message :";
		last_request = UNKNOWN_REQUEST;
	}

	message.description = ss.str();
}


void parseComment(Message &message)
{/*
	std::ostringstream ss; // (message.description);
	ss << (unsigned char) message.raw_status_and_data_bytes[0].data;
	message.description = ss.str();
	*/
}

// Purpose: Parse a response (from the machine)
void parseResponse(Message &message)
{
	// If SAS
	std::ostringstream ss; // (message.description);

	if (message.raw_status_and_data_bytes[0].addressByte())
	{
		ss << "CHIRP[";
		ss << std::hex << std::setfill('0') << std::setw(2) << red << (int)message.raw_status_and_data_bytes[0].data << "]";
	}
	else
	{
		switch (last_request)
		{
		case BP_REQUEST:
			ss << "BP[Shouldn't be a response - ";
			ss << std::hex << std::setfill('0') << std::setw(2) << (int)message.raw_status_and_data_bytes[0].data << "]";
			break;

		case GP_REQUEST:
			ss << exceptions[message.raw_status_and_data_bytes[0].data] << ':';
			break;

		case LP_REQUEST:
			ss << long_poll[message.raw_status_and_data_bytes[0].data] << ':';
			break;

		default:
			ss << "??[";
			ss << std::hex << std::setfill('0') << std::setw(2) << (int)message.raw_status_and_data_bytes[0].data << "]";
			break;
		}
	}

	//	current_message.description = ss.str();
	message.description = ss.str();
}

// Purpose: Parse an individual message and add the 
void parseMessage(Message &message)
{
	switch (message.getDirection())
	{
	case Direction::RX:
		parseRequest(message);
		break;

	case Direction::TX:
		parseResponse(message);
		break;

	case Direction::COMMENT:
		parseComment(message);
		break;

	default:
		message.description += " Invalid direction";
		break;
	}
}

struct space_out : std::numpunct < char >
{
	char do_thousands_sep()   const { return ' '; } // separate with spaces
	std::string do_grouping() const { return "\1"; } // groups of 1 digit
};

struct g3 : std::numpunct < char >
{
	std::string do_grouping() const { return "\3"; }
};

int _tmain(int argc, _TCHAR* argv[])
{
	boost::chrono::system_clock::time_point start = boost::chrono::system_clock::now();
	//std::locale loc(std::cout.getloc());
	//std::cout.imbue(std::locale(std::cout.getloc(), new g3)); // Setup 3 digit grouping (i.e. thousands separator)

	//	std::string filename("FAIL.log");
	//std::string filename("Test.log");
	//std::string filename("IGT_00012952A0BF_SAS1_1419982688.log");
	std::string filename("Test_Comment.log");

	try
	{
		std::ifstream myfile(filename, std::ios::in | std::ios::binary);
		if (myfile.is_open())
		{
#ifdef __VERBOSE_FILE_INFORMATION__
			myfile.seekg(0, std::ios::end);
			std::fstream::pos_type size = myfile.tellg();
			myfile.seekg(0, std::ios::beg);
			std::cout << filename.c_str() << " open : size=" << size << " bytes" << std::endl;
#endif // __VERBOSE_FILE_INFORMATION__

			// Read the stream of bytes from the file into a vector
			std::cout << "Open " << filename << std::endl;
			start = boost::chrono::system_clock::now();
			std::vector<BYTE> bytes((std::istreambuf_iterator<char>(myfile)), std::istreambuf_iterator<char>());
			myfile.close();
			boost::chrono::duration<double> sec = boost::chrono::system_clock::now() - start;
			std::cout << "took " << sec.count() << " seconds to read " << bytes.size() << " bytes (" << bytes.size() / sec.count() << " BPS)" << std::endl;

			// Parse the stream of bytes from the vector into a list of messages
			std::cout << bytes.size() << " bytes to scan" << std::endl;
			start = boost::chrono::system_clock::now();
			for (std::vector<unsigned char>::size_type i = 0,
				 size = ((bytes.size() / 2) * 2); // Force to multiple of two so they always come in status:data pairs
				 i != size;
			    )
			{
				if (!(i % 5000))
				{
					if (i)
					{
						boost::chrono::duration<double> sec = boost::chrono::system_clock::now() - start;
						std::cout << "\r " << i / sec.count() << " BPS (i=" << i << ", sec=" << sec << ")\r";
					}
				}
				if (!(i % 500))
				{
					updateSpinner(i);
				}

				// Read next status/data bytes from stream of bytes
				unsigned char status = (unsigned char)bytes[i++];
				unsigned char data = (unsigned char)bytes[i++];
				StatusAndData status_and_data(status, data);

				// Assemble into messages
				searchForMessage(status_and_data);
			}
		}
		else
		{
			throw ("File could not be opened");
		}
	}
	catch (std::exception const& e)
	{
		std::cout << "Error while processing '" << filename << "' : " << e.what() << std::endl;
	}

	// Parse individual messages
	std::cout << messages.size() << " messages to parse" << std::endl;
	for (std::vector<Message>::size_type i = 0; i != messages.size(); ++i)
	{
		parseMessage(messages[i]);
	}

	// Display list of messages pulled from byte stream
	std::cout << "Display " << messages.size() << " parsed messages" << std::endl;
	for (auto iter : messages)
	{
		std::cout << iter << std::endl;
	}

	return 0;
}
